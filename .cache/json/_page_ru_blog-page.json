{"data":{"prismicPage":{"url":"/page/ru/blog-page","uid":"blog-page","type":"page","id":"bfc9b41f-c3fc-5969-aeac-dd139fb1292b","lang":"ru","alternate_languages":[{"id":"YMIl-BEAACIA2XBL","type":"page","lang":"en-us","uid":"blog-page","url":"/page/blog-page"},{"id":"YMImExEAACIA2XDG","type":"page","lang":"fr-fr","uid":"blog-page","url":"/page/fr-fr/blog-page"}],"data":{"body":[{"id":"db591ac2-d8c3-5d2b-af1f-94d9b0ac051f","items":[{"blog_item_title":{"html":"<h3>Sony официально представила дрон Airpeak S1 по цене $ 9000 (без камеры)</h3>","raw":[{"type":"heading3","text":"Sony официально представила дрон Airpeak S1 по цене $ 9000 (без камеры)","spans":[]}],"text":"Sony официально представила дрон Airpeak S1 по цене $ 9000 (без камеры)"},"content":{"html":"<p>Ассоциация украинских автомобилестроительных компаний «Укравтопром» подвела локального авторынка для дерев пяти месяцев текущего направления, выявило наиболее популярные новые модели. По цей период украинцы Купи почти 40 тыс. Новых легковых автомобилей (39,6 тыс.).</p>\n    <div data-oembed=\"https://youtu.be/7CZTLogln34\"\n      data-oembed-type=\"video\"\n      data-oembed-provider=\"YouTube\"\n      >\n\n      <iframe width=\"200\" height=\"113\" src=\"https://www.youtube.com/embed/7CZTLogln34?feature=oembed\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n    </div>\n  <p>Наибольшим спросом в этом периоде имел автомобиль Toyota RAV4, с января по май эту модель приобрели 2586 автомобилистов. Вторым по популярности стал корейский компактный кроссовер Kia Sportage, за который своими кошельками проголосовали 2235 покупателей. Замыкает лидирующую тройку Renault Duster, в активе этой модели 2110 регистраций.</p>\n    <p class=\" block-img\">\n      <img src=\"https://images.prismic.io/multilang-prismic-gatsby-example/ede3bd54-2b76-4779-a4bb-df5409cc667e_foto-2-2-5.jpg?auto=compress,format\" alt=\"car\" copyright=\"\">\n    </p>\n  <ol><li>Toyota RAV4 — 2586 шт.</li><li>Kia Sportage — 2235 шт.</li><li>Renault Duster — 2110 шт.</li><li>Renault Sandero – 1207 шт.</li><li>Renault Logan – 1134 шт.</li><li>Nissan Qashqai – 1117 шт.</li><li>Volkswagen Touareg – 966 шт.</li><li>Hyundai Tucson – 877 шт.</li><li>Toyota Land Cruiser Prado – 846 шт.</li><li>Mazda CX5 – 823 шт.</li></ol><p>Таким образом, 9 из 10 самых популярных автомобилей на украинском рынке кроссоверами. Всего же по итогам первых пяти месяцев текущего года кроссоверам принадлежит 3/4 украинского рынка новых легковых авто.<br /><br />Отметим, что только в мае украинцы приобрели 8,5 тыс. Новых легковых автомобилей, 33,2 тыс. Подержанных иномарок и 622 электромобиля.</p>","raw":[{"type":"paragraph","text":"Ассоциация украинских автомобилестроительных компаний «Укравтопром» подвела локального авторынка для дерев пяти месяцев текущего направления, выявило наиболее популярные новые модели. По цей период украинцы Купи почти 40 тыс. Новых легковых автомобилей (39,6 тыс.).","spans":[]},{"type":"embed","oembed":{"height":113,"width":200,"embed_url":"https://youtu.be/7CZTLogln34","type":"video","version":"1.0","title":"Starship | SN15 | Flight Test Recap","author_name":"SpaceX","author_url":"https://www.youtube.com/c/SpaceX","provider_name":"YouTube","provider_url":"https://www.youtube.com/","cache_age":null,"thumbnail_url":"https://i.ytimg.com/vi/7CZTLogln34/hqdefault.jpg","thumbnail_width":480,"thumbnail_height":360,"html":"<iframe width=\"200\" height=\"113\" src=\"https://www.youtube.com/embed/7CZTLogln34?feature=oembed\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>"}},{"type":"paragraph","text":"Наибольшим спросом в этом периоде имел автомобиль Toyota RAV4, с января по май эту модель приобрели 2586 автомобилистов. Вторым по популярности стал корейский компактный кроссовер Kia Sportage, за который своими кошельками проголосовали 2235 покупателей. Замыкает лидирующую тройку Renault Duster, в активе этой модели 2110 регистраций.","spans":[]},{"type":"image","url":"https://images.prismic.io/multilang-prismic-gatsby-example/ede3bd54-2b76-4779-a4bb-df5409cc667e_foto-2-2-5.jpg?auto=compress,format","alt":"car","copyright":null,"dimensions":{"width":1200,"height":900}},{"type":"o-list-item","text":"Toyota RAV4 — 2586 шт.","spans":[]},{"type":"o-list-item","text":"Kia Sportage — 2235 шт.","spans":[]},{"type":"o-list-item","text":"Renault Duster — 2110 шт.","spans":[]},{"type":"o-list-item","text":"Renault Sandero – 1207 шт.","spans":[]},{"type":"o-list-item","text":"Renault Logan – 1134 шт.","spans":[]},{"type":"o-list-item","text":"Nissan Qashqai – 1117 шт.","spans":[]},{"type":"o-list-item","text":"Volkswagen Touareg – 966 шт.","spans":[]},{"type":"o-list-item","text":"Hyundai Tucson – 877 шт.","spans":[]},{"type":"o-list-item","text":"Toyota Land Cruiser Prado – 846 шт.","spans":[]},{"type":"o-list-item","text":"Mazda CX5 – 823 шт.","spans":[]},{"type":"paragraph","text":"Таким образом, 9 из 10 самых популярных автомобилей на украинском рынке кроссоверами. Всего же по итогам первых пяти месяцев текущего года кроссоверам принадлежит 3/4 украинского рынка новых легковых авто.\n\nОтметим, что только в мае украинцы приобрели 8,5 тыс. Новых легковых автомобилей, 33,2 тыс. Подержанных иномарок и 622 электромобиля.","spans":[]}],"text":"Ассоциация украинских автомобилестроительных компаний «Укравтопром» подвела локального авторынка для дерев пяти месяцев текущего направления, выявило наиболее популярные новые модели. По цей период украинцы Купи почти 40 тыс. Новых легковых автомобилей (39,6 тыс.).  Наибольшим спросом в этом периоде имел автомобиль Toyota RAV4, с января по май эту модель приобрели 2586 автомобилистов. Вторым по популярности стал корейский компактный кроссовер Kia Sportage, за который своими кошельками проголосовали 2235 покупателей. Замыкает лидирующую тройку Renault Duster, в активе этой модели 2110 регистраций.  Toyota RAV4 — 2586 шт. Kia Sportage — 2235 шт. Renault Duster — 2110 шт. Renault Sandero – 1207 шт. Renault Logan – 1134 шт. Nissan Qashqai – 1117 шт. Volkswagen Touareg – 966 шт. Hyundai Tucson – 877 шт. Toyota Land Cruiser Prado – 846 шт. Mazda CX5 – 823 шт. Таким образом, 9 из 10 самых популярных автомобилей на украинском рынке кроссоверами. Всего же по итогам первых пяти месяцев текущего года кроссоверам принадлежит 3/4 украинского рынка новых легковых авто.\n\nОтметим, что только в мае украинцы приобрели 8,5 тыс. Новых легковых автомобилей, 33,2 тыс. Подержанных иномарок и 622 электромобиля."},"date":"2021-06-10","item_image":{"url":"https://images.prismic.io/slicemachine-blank/6b2bf485-aa12-44ef-8f06-dce6b91b9309_dancing.png?auto=compress%2Cformat"},"short_description":{"html":"<p>Ассоциация украинских автомобилестроительных компаний «Укравтопром» подвела локального авторынка для дерев пяти месяцев текущего направления, выявило наиболее популярные новые модели. По цей период украинцы Купи почти 40 тыс. Новых легковых автомобилей (39,6 тыс.).</p>","raw":[{"type":"paragraph","text":"Ассоциация украинских автомобилестроительных компаний «Укравтопром» подвела локального авторынка для дерев пяти месяцев текущего направления, выявило наиболее популярные новые модели. По цей период украинцы Купи почти 40 тыс. Новых легковых автомобилей (39,6 тыс.).","spans":[]}],"text":"Ассоциация украинских автомобилестроительных компаний «Укравтопром» подвела локального авторынка для дерев пяти месяцев текущего направления, выявило наиболее популярные новые модели. По цей период украинцы Купи почти 40 тыс. Новых легковых автомобилей (39,6 тыс.)."}},{"blog_item_title":{"html":"<h3>SpaceX идет на рекорд — нацеливается на 20 запусков Falcon 9 за первое полугодие 2021 года</h3>","raw":[{"type":"heading3","text":"SpaceX идет на рекорд — нацеливается на 20 запусков Falcon 9 за первое полугодие 2021 года","spans":[]}],"text":"SpaceX идет на рекорд — нацеливается на 20 запусков Falcon 9 за первое полугодие 2021 года"},"content":{"html":"\n    <p class=\" block-img\">\n      <img src=\"https://images.prismic.io/multilang-prismic-gatsby-example/05e8e11d-7d5a-4467-a9a1-e1406ef1abf3_e3svv47xiaapuma.jpg?auto=compress,format\" alt=\"\" copyright=\"\">\n    </p>\n  <p>В первую неделю июня SpaceX провела два успешных запуска Falcon 9: 3 июня она отправила грузовик Dragon 2 с 22-й миссией снабжения МКС, а 6 июня — вывела на орбиту 7-тонный телекоммуникационный спутник SXM-8 для поддержки стримингового вещания в интересах компании SiriusXM. И в расписании на этот месяц значатся еще два запуска Falcon 9.</p><p>Ближайший запуск запланирован на 17 июня — это будет миссия по выводу на орбиту спутника GPS III-05 (Neil Armstrong) для космических сил США. И впервые для отправки груза «национальной безопасности» по контракту с американскими военными будет использоваться не полностью новая, а восстановленная первая ступень — F9 B5 B1062.2 (она же отвечала за отправку предыдущего аппарата <a  href=\"https://itc.ua/news/spacex-vyvela-na-orbitu-sputnik-gps-iii-04-dlya-kosmicheskih-sil-ssha-sleduyushhaya-missiya-pervyj-ekspluataczionnyj-polet-crew-dragon-crew-1-k-mks/\">GPS III-04 в ноябре 2020 года</a>). Ранее компания Илона Маска выиграла тендер на запуск пяти из первых шести аппаратов данного типа. И если все пройдет удачно, то в будущем SpaceX разрешат использовать Falcon 9 B1062 в третий раз для запуска спутника GPS III SV06 (четвертый квартал 2021 года или начало 2022 года).</p><p>Ровно через неделю после GPS III-05 компания SpaceX планирует еще один запуск Falcon 9 с миссией Transporter-2 — это будет уже второй запуск по программе райдшеринга <a target=\"_blank\" rel=\"noopener\" href=\"https://www.spacex.com/rideshare/\">SmallSat Rideshare Program</a>. Да, речь о тех самых «космических маршрутках» SpaceX, в рамках которого компания пакетом отправляет десятки небольших спутников для разных заказчиков. В прошлый раз компания установила мировой рекорд, отправив на орбиту за раз 143 спутника.</p><p><a  href=\"https://itc.ua/news/spacex-ustanovila-novyj-mirovoj-rekord-raketa-falcon-9-vyvela-na-orbitu-razom-143-sputnika/\">SpaceX установила новый мировой рекорд — ракета Falcon 9 вывела на орбиту разом 143 спутника</a></p><p></p><p>Если все пойдет по плану, то июнь 2021 станет третьим месяцем в истории SpaceX с четырьмя успешными запусками. Пока больше четырех Falcon 9 в месяц SpaceX не запускала. Все четыре июньских запуска — оплачены сторонними заказчиками, что положительно скажется на платежном балансе компании, которая последние шесть месяцев в основном запускала интернет-спутники Starlink в собственных интересах. Что еще важнее, SpaceX завершит первое полугодие 2021 года с рекордным результатом в 20 успешных миссий и до конца года при сохранении нынешних темпов сможет выйти на впечатляющий результат в 40 запусков.</p>","raw":[{"type":"image","url":"https://images.prismic.io/multilang-prismic-gatsby-example/05e8e11d-7d5a-4467-a9a1-e1406ef1abf3_e3svv47xiaapuma.jpg?auto=compress,format","alt":null,"copyright":null,"dimensions":{"width":1200,"height":800}},{"type":"paragraph","text":"В первую неделю июня SpaceX провела два успешных запуска Falcon 9: 3 июня она отправила грузовик Dragon 2 с 22-й миссией снабжения МКС, а 6 июня — вывела на орбиту 7-тонный телекоммуникационный спутник SXM-8 для поддержки стримингового вещания в интересах компании SiriusXM. И в расписании на этот месяц значатся еще два запуска Falcon 9.","spans":[]},{"type":"paragraph","text":"Ближайший запуск запланирован на 17 июня — это будет миссия по выводу на орбиту спутника GPS III-05 (Neil Armstrong) для космических сил США. И впервые для отправки груза «национальной безопасности» по контракту с американскими военными будет использоваться не полностью новая, а восстановленная первая ступень — F9 B5 B1062.2 (она же отвечала за отправку предыдущего аппарата GPS III-04 в ноябре 2020 года). Ранее компания Илона Маска выиграла тендер на запуск пяти из первых шести аппаратов данного типа. И если все пройдет удачно, то в будущем SpaceX разрешат использовать Falcon 9 B1062 в третий раз для запуска спутника GPS III SV06 (четвертый квартал 2021 года или начало 2022 года).","spans":[{"start":377,"end":406,"type":"hyperlink","data":{"link_type":"Web","url":"https://itc.ua/news/spacex-vyvela-na-orbitu-sputnik-gps-iii-04-dlya-kosmicheskih-sil-ssha-sleduyushhaya-missiya-pervyj-ekspluataczionnyj-polet-crew-dragon-crew-1-k-mks/"}}]},{"type":"paragraph","text":"Ровно через неделю после GPS III-05 компания SpaceX планирует еще один запуск Falcon 9 с миссией Transporter-2 — это будет уже второй запуск по программе райдшеринга SmallSat Rideshare Program. Да, речь о тех самых «космических маршрутках» SpaceX, в рамках которого компания пакетом отправляет десятки небольших спутников для разных заказчиков. В прошлый раз компания установила мировой рекорд, отправив на орбиту за раз 143 спутника.","spans":[{"start":166,"end":192,"type":"hyperlink","data":{"link_type":"Web","url":"https://www.spacex.com/rideshare/","target":"_blank"}}]},{"type":"paragraph","text":"SpaceX установила новый мировой рекорд — ракета Falcon 9 вывела на орбиту разом 143 спутника","spans":[{"start":0,"end":92,"type":"hyperlink","data":{"link_type":"Web","url":"https://itc.ua/news/spacex-ustanovila-novyj-mirovoj-rekord-raketa-falcon-9-vyvela-na-orbitu-razom-143-sputnika/"}}]},{"type":"paragraph","text":"","spans":[]},{"type":"paragraph","text":"Если все пойдет по плану, то июнь 2021 станет третьим месяцем в истории SpaceX с четырьмя успешными запусками. Пока больше четырех Falcon 9 в месяц SpaceX не запускала. Все четыре июньских запуска — оплачены сторонними заказчиками, что положительно скажется на платежном балансе компании, которая последние шесть месяцев в основном запускала интернет-спутники Starlink в собственных интересах. Что еще важнее, SpaceX завершит первое полугодие 2021 года с рекордным результатом в 20 успешных миссий и до конца года при сохранении нынешних темпов сможет выйти на впечатляющий результат в 40 запусков.","spans":[]}],"text":" В первую неделю июня SpaceX провела два успешных запуска Falcon 9: 3 июня она отправила грузовик Dragon 2 с 22-й миссией снабжения МКС, а 6 июня — вывела на орбиту 7-тонный телекоммуникационный спутник SXM-8 для поддержки стримингового вещания в интересах компании SiriusXM. И в расписании на этот месяц значатся еще два запуска Falcon 9. Ближайший запуск запланирован на 17 июня — это будет миссия по выводу на орбиту спутника GPS III-05 (Neil Armstrong) для космических сил США. И впервые для отправки груза «национальной безопасности» по контракту с американскими военными будет использоваться не полностью новая, а восстановленная первая ступень — F9 B5 B1062.2 (она же отвечала за отправку предыдущего аппарата GPS III-04 в ноябре 2020 года). Ранее компания Илона Маска выиграла тендер на запуск пяти из первых шести аппаратов данного типа. И если все пройдет удачно, то в будущем SpaceX разрешат использовать Falcon 9 B1062 в третий раз для запуска спутника GPS III SV06 (четвертый квартал 2021 года или начало 2022 года). Ровно через неделю после GPS III-05 компания SpaceX планирует еще один запуск Falcon 9 с миссией Transporter-2 — это будет уже второй запуск по программе райдшеринга SmallSat Rideshare Program. Да, речь о тех самых «космических маршрутках» SpaceX, в рамках которого компания пакетом отправляет десятки небольших спутников для разных заказчиков. В прошлый раз компания установила мировой рекорд, отправив на орбиту за раз 143 спутника. SpaceX установила новый мировой рекорд — ракета Falcon 9 вывела на орбиту разом 143 спутника  Если все пойдет по плану, то июнь 2021 станет третьим месяцем в истории SpaceX с четырьмя успешными запусками. Пока больше четырех Falcon 9 в месяц SpaceX не запускала. Все четыре июньских запуска — оплачены сторонними заказчиками, что положительно скажется на платежном балансе компании, которая последние шесть месяцев в основном запускала интернет-спутники Starlink в собственных интересах. Что еще важнее, SpaceX завершит первое полугодие 2021 года с рекордным результатом в 20 успешных миссий и до конца года при сохранении нынешних темпов сможет выйти на впечатляющий результат в 40 запусков."},"date":"2021-06-10","item_image":{"url":"https://images.prismic.io/slicemachine-blank/76bc1e6e-67a0-41d9-9c3c-5a5d3161e6a9_bikini.png?auto=compress%2Cformat"},"short_description":{"html":"<p>В первую неделю июня SpaceX провела два успешных запуска Falcon 9: 3 июня она отправила грузовик Dragon 2 с 22-й миссией снабжения МКС, а 6 июня — вывела на орбиту 7-тонный телекоммуникационный спутник SXM-8 для поддержки стримингового вещания в интересах компании SiriusXM. И в расписании на этот месяц значатся еще два запуска Falcon 9.</p>","raw":[{"type":"paragraph","text":"В первую неделю июня SpaceX провела два успешных запуска Falcon 9: 3 июня она отправила грузовик Dragon 2 с 22-й миссией снабжения МКС, а 6 июня — вывела на орбиту 7-тонный телекоммуникационный спутник SXM-8 для поддержки стримингового вещания в интересах компании SiriusXM. И в расписании на этот месяц значатся еще два запуска Falcon 9.","spans":[]}],"text":"В первую неделю июня SpaceX провела два успешных запуска Falcon 9: 3 июня она отправила грузовик Dragon 2 с 22-й миссией снабжения МКС, а 6 июня — вывела на орбиту 7-тонный телекоммуникационный спутник SXM-8 для поддержки стримингового вещания в интересах компании SiriusXM. И в расписании на этот месяц значатся еще два запуска Falcon 9."}},{"blog_item_title":{"html":"<h3>Тестирование альфа-версии React 18</h3>","raw":[{"type":"heading3","text":"Тестирование альфа-версии React 18","spans":[]}],"text":"Тестирование альфа-версии React 18"},"content":{"html":"<p>Примечательные функции, которые вы уже можете попробовать в React 18, следующие:</p><ul><li>Новый ReactDOM.createRoot()API, заменяющийReactDOM.render()</li><li>Улучшения пакетной обработки для меньшего количества рендеров</li><li>Поддержка SSR для &lt;Suspense&gt;компонента</li><li>startTransition API для несрочных обновлений состояния</li></ul><p>Чтобы опробовать React 18 Alpha в своем проекте, вы можете установить @alphaверсию из NPM или Yarn:</p><pre>npm install react @ alpha react-dom @ alpha \n# или \nпряжа add response @ alpha react-dom @ alpha</pre><p>Если вы загрузите свое приложение React с помощью приложения Create React, вы можете столкнуться с ошибкой, could not resolve dependencyвызванной react-scriptsследующим:</p><pre>Не удалось разрешить зависимость: \npeer response @ &quot;&gt; = 16&quot; из response-scripts@4.0.3</pre><p>Вы можете использовать --forceфлаг, чтобы вы могли обновлять как библиотеки, так reactи react-dom:</p><pre>npm установить react @ alpha react-dom @ alpha --force</pre><p>Это руководство поможет вам изучить новые функции, уже представленные в React 18 Alpha, которые я смог попробовать сам.</p><h1>ReactDOM.createRoot () API объяснил</h1><p>ReactDOM.createRoot()Метод заменяет ReactDOM.render()метод , который обычно используется в качестве точки входа вашего React приложения.</p><p>Этот метод создан для предотвращения сбоя вашего приложения при обновлении React 18. Новый метод также позволяет создавать производственную сборку с использованием React 18 Alpha и сравнивать производительность с React 17.</p><p>Вот пример того, как использовать createRoot()метод:</p><pre>импортировать React из React; \nимпортировать ReactDOM из react-dom; \nимпортировать приложение из &#39;./App&#39;;const container = document.getElementById (&#39;корень&#39;);// Создаем корень. \nconst root = ReactDOM.createRoot (контейнер);// Отрисовываем верхний компонент в корень. \nroot.render (&lt;Приложение /&gt;);</pre><p>Когда вы обновляетесь до React 18, в консоли, когда вы используете ее в .render()качестве точки входа, появится журнал ошибок , в котором вам будет предложено переключиться на новый Root API.</p><p>Вы можете попробовать функции React 18 <strong>только</strong> после того, как воспользуетесь createRoot()методом.</p><p>Для получения дополнительной информации вы можете посетить <a  href=\"https://github.com/reactwg/react-18/discussions/5\">страницу обсуждения createRoot здесь</a> .</p><h1>Улучшения автоматического пакетирования для рендеринга</h1><p>Как вы, возможно, уже знаете, React - это библиотека, которая повторно отображает пользовательский интерфейс в результате изменений состояния.</p><p>Например, когда вы меняете значение произвольного состояния с trueна false, React должен «реагировать» путем повторного рендеринга пользовательского интерфейса, настраивая то, что вы видите на экране, в соответствии с написанным вами кодом.</p><p>Следующий &lt;App&gt;компонент будет отображать заголовок черного или красного цвета в соответствии со colorзначением состояния:</p><pre>функция App () { \n  const [цвет, setColor] = useState (false);  функция handleClick () { \n    setColor ((цвет) =&gt;! цвет); // реагируем на повторные рендеры \n  }  return ( \n    &lt;div&gt; \n      &lt;button onClick = {handleClick}&gt; Изменить цвет &lt;/button&gt; \n      &lt;h1 style = {{color: color? &quot;red&quot;: &quot;black&quot;}}&gt; Привет &lt;/h1&gt; \n    &lt;/div&gt; \n  ); \n}</pre><p>Каждый раз, когда setColor()метод выполняется, React немедленно повторно отображает пользовательский интерфейс.</p><p><strong>Пакетная обработка</strong> - это механизм, используемый React для группировки нескольких обновлений состояния в один повторный рендеринг. Благодаря пакетной обработке вы избежите ненужных рендеров и оптимизируете процесс рендеринга.</p><p>Возвращаясь к &lt;App&gt;примеру компонента, давайте добавим еще одно состояние, которое обновляется при handleClick()вызове метода:</p><pre>функция App () { \n  const [цвет, setColor] = useState (false); \n  const [clickCount, setClickCount] = useState (0); \n  \n  функция handleClick () { \n    setColor ((цвет) =&gt;! цвет); \n    setClickCount ((клик) =&gt; клик + 1); \n  }  return ( \n    &lt;div&gt; \n      &lt;button onClick = {handleClick}&gt; Изменить цвет &lt;/button&gt; \n      &lt;h1 style = {{color: color? &quot;red&quot;: &quot;black&quot;}}&gt; \n        Здравствуйте, у вас количество кликов {clickCount} \n      &lt;/ h1&gt;\n     &lt;/div&gt; \n  ); \n}</pre><p>Без механизма пакетной обработки приведенный выше код будет повторно отображать пользовательский интерфейс дважды при каждом handleClick()вызове метода. Сначала обновить цвет, затем еще раз, чтобы обновить счетчик кликов.</p><p>Однако механизм пакетной обработки, реализованный в React 17, не был согласован. Пакетирование не произойдет, если вы вызовете методы обновления состояния из обратного вызова.</p><p>Например, предположим, что вы сначала извлекаете данные из API перед вызовом setColor()и setClickCount(). Механизм пакетной обработки не сработает, и React дважды повторно отрендерит пользовательский интерфейс:</p><pre>function handleClick () { \n  fetchUserData (). then (() =&gt; { \n    setCount (c =&gt; c + 1); // вызывает повторную визуализацию! \n    setFlag (f =&gt;! f); // вызывает повторную визуализацию ! \n  }); \n}function fetchUserDate () { \n  // код для краткости опущен ... \n}</pre><p>То же самое происходит, когда вы помещаете методы обновления состояния в setTimeout()обратный вызов:</p><pre>функция handleClick () { \n  setTimeout (() =&gt; { \n    setColor ((цвет) =&gt;! цвет); \n    setClickCount ((щелчок) =&gt; щелчок + 1); \n  }, 1000); \n}</pre><p>React 18 решил проблему выше, улучшив механизм дозирования.</p><p>Теперь пакетная обработка запускается, когда более одного метода обновления состояния вызывается из внутренних обещаний, setTimeout, собственных обработчиков событий или любого другого события, которое ранее не было обработано React.</p><p>Страницу обсуждения этой функции можно найти <a  href=\"https://github.com/reactwg/react-18/discussions/21\">здесь</a> .</p><h1>Поддержка SSR для &lt;Suspense&gt;</h1><p>&lt;Suspense&gt;Компонент является особенностью Реагировать библиотеки , которая позволяет ждать некоторого кода к нагрузке путем добавления fallbackкомпонента , чтобы сделать до загрузки кода.</p><p>Вот пример &lt;Suspense&gt;в действии:</p><pre>&lt;Suspense fallback = {&lt;LoadingSpinner /&gt;}&gt;\n   &lt;UserProfile /&gt; \n&lt;Suspense /&gt;</pre><p>Вы можете &lt;Suspense&gt;подробно прочитать об этом в документации по React.</p><p>В React 18 эта &lt;Suspense&gt;функция поддерживается даже при рендеринге компонентов на сервере с использованием SSR. Это обновление позволяет обернуть компоненты, отображаемые сервером, внутри &lt;Suspense&gt;компонента.</p><p>Любые компоненты на стороне сервера, заключенные внутри, &lt;Suspense&gt;будут транслироваться как HTML, используя fallbackсначала компонент, и как только компонент будет готов, React отправит новые биты HTML для замены fallbackкомпонента.</p><p>Например, предположим, что у вас есть &lt;Article&gt;следующие &lt;Comments&gt;компоненты и a :</p><pre>&lt;Layout&gt; \n  &lt; Article /&gt; \n  &lt;Suspense fallback = {&lt;Spinner /&gt;}&gt;\n     &lt;Comments /&gt; \n  &lt;/Suspense&gt;\n &lt;/Layout&gt;</pre><p>При рендеринге с сервера &lt;Article&gt;компонент будет иметь приоритет, а &lt;Comments&gt;компонент будет заменен резервным компонентом &lt;Spinner&gt;. Как только &lt;Comments&gt;компонент отобразится на сервере, React отправит его в браузер, заменив &lt;Spinner&gt;компонент.</p><p>Для более подробного объяснения SSR и Suspense вы можете посетить следующую страницу <a  href=\"https://github.com/reactwg/react-18/discussions/37\">обсуждения GitHub</a> .</p><h1>API startTransition для несрочных обновлений состояния</h1><p>startTransitionAPI является новой функцией в React 18 предназначен , чтобы помочь ваше пребывание приложений реагирующий при обновлении состояния , которое требует тяжелой мощности вычислений для визуализации пользовательского интерфейса.</p><p>Одним из примеров такого обновления является создание поля ввода, которое фильтрует список данных. Обновление состояния требует, чтобы ваше приложение React вычисляло и отображало только те данные, которые соответствуют фильтру.</p><p>У вас может быть два метода обновления состояния: один для обработки изменения входного значения, а другой для обработки запроса фильтра.</p><pre>// Устанавливаем состояние входного значения \nsetInputValue (input); \n\n// Устанавливаем ввод поискового запроса. Отражено позже в пользовательском интерфейсе \nsetSearchQuery (input);</pre><p>Когда количество фильтруемых элементов увеличивается, вычисления для фильтрации элементов также увеличиваются. Это может привести к тому, что ваше приложение будет работать <em>медленно или даже зависнуть</em> во время выполнения вычислений.</p><p>Чтобы смягчить эту проблему, React позволяет отмечать определенные обновления как <strong>переходы </strong><em><strong></strong>.</em></p><p>Обновления перехода обрабатываются как несрочные обновления, что позволяет React в первую очередь расставлять приоритеты по срочным обновлениям.</p><p>Вернемся к примеру, обновление поискового запроса может быть отложено, если поместить его в startTransitionAPI следующим образом:</p><pre>импортировать {startTransition} из &quot;реагировать&quot;;// Срочно: показать, что было набрано \nsetInputValue (input);// Помечаем любые обновления состояния внутри как переходы \nstartTransition (() =&gt; { \n  setSearchQuery (input); \n});</pre><p>Обернутые обновления startTransitionбудут прерваны при запуске более важных обновлений.</p><p>В приведенном выше примере обновление перехода для поискового запроса будет остановлено, когда пользователь наберет несколько символов в строке. Это оптимизирует производительность повторного рендеринга React и устраняет ненужные вычисления для устаревших обновлений.</p><p>Вы можете найти больше информации о <a  href=\"https://github.com/reactwg/react-18/discussions/41\">startTransition API здесь</a> .</p><h1>Заключение</h1><p>Хотя некоторые функции, упомянутые на <a  href=\"https://github.com/reactwg/react-18/discussions/4\">вводной</a> странице <a  href=\"https://github.com/reactwg/react-18/discussions/4\">React 18,</a> еще даже не были выпущены ( useDeferredValueи, &lt;SuspenseList&gt;например)</p><p>React 18 Alpha уже привносит в React несколько интересных функций, улучшающих параллелизм библиотеки. Вы можете попробовать это, установив @alphaсборку reactи react-domбиблиотеку.</p><p>Также пока нет обновлений <a  href=\"https://blog.bitsrc.io/react-server-components-1ca621ac2519\">для компонентов сервера React</a> , но новые параллельные функции, такие как поддержка SSR для приостановки и потоковая передача HTML с сервера, могут помочь в реализации компонентов сервера позже.</p><p><a  href=\"https://reactjs.org/blog/2021/06/08/the-plan-for-react-18.html\">Релиз график React 18</a> выглядит следующим образом :</p><ul><li>Альфа-версия для сбора отзывов и поддержки рабочей группы React (доступна сегодня)</li><li>Публичная бета-версия для всех остальных (по крайней мере, через несколько месяцев после выпуска альфа-версии)</li><li>Сборка Release Candidate (RC) через несколько недель после публичной бета-версии</li><li>Стабильный выпуск выйдет через несколько недель после RC.</li></ul><p>Спасибо, что прочитали эту статью. Не стесняйтесь попробовать React 18 самостоятельно, но имейте в виду, что могут быть критические изменения в зависимости от того, насколько сложным является ваше приложение React.</p>","raw":[{"type":"paragraph","text":"Примечательные функции, которые вы уже можете попробовать в React 18, следующие:","spans":[]},{"type":"list-item","text":"Новый ReactDOM.createRoot()API, заменяющийReactDOM.render()","spans":[]},{"type":"list-item","text":"Улучшения пакетной обработки для меньшего количества рендеров","spans":[]},{"type":"list-item","text":"Поддержка SSR для <Suspense>компонента","spans":[]},{"type":"list-item","text":"startTransition API для несрочных обновлений состояния","spans":[]},{"type":"paragraph","text":"Чтобы опробовать React 18 Alpha в своем проекте, вы можете установить @alphaверсию из NPM или Yarn:","spans":[]},{"type":"preformatted","text":"npm install react @ alpha react-dom @ alpha \n# или \nпряжа add response @ alpha react-dom @ alpha","spans":[]},{"type":"paragraph","text":"Если вы загрузите свое приложение React с помощью приложения Create React, вы можете столкнуться с ошибкой, could not resolve dependencyвызванной react-scriptsследующим:","spans":[]},{"type":"preformatted","text":"Не удалось разрешить зависимость: \npeer response @ \"> = 16\" из response-scripts@4.0.3","spans":[]},{"type":"paragraph","text":"Вы можете использовать --forceфлаг, чтобы вы могли обновлять как библиотеки, так reactи react-dom:","spans":[]},{"type":"preformatted","text":"npm установить react @ alpha react-dom @ alpha --force","spans":[]},{"type":"paragraph","text":"Это руководство поможет вам изучить новые функции, уже представленные в React 18 Alpha, которые я смог попробовать сам.","spans":[]},{"type":"heading1","text":"ReactDOM.createRoot () API объяснил","spans":[]},{"type":"paragraph","text":"ReactDOM.createRoot()Метод заменяет ReactDOM.render()метод , который обычно используется в качестве точки входа вашего React приложения.","spans":[]},{"type":"paragraph","text":"Этот метод создан для предотвращения сбоя вашего приложения при обновлении React 18. Новый метод также позволяет создавать производственную сборку с использованием React 18 Alpha и сравнивать производительность с React 17.","spans":[]},{"type":"paragraph","text":"Вот пример того, как использовать createRoot()метод:","spans":[]},{"type":"preformatted","text":"импортировать React из React; \nимпортировать ReactDOM из react-dom; \nимпортировать приложение из './App';const container = document.getElementById ('корень');// Создаем корень. \nconst root = ReactDOM.createRoot (контейнер);// Отрисовываем верхний компонент в корень. \nroot.render (<Приложение />);","spans":[]},{"type":"paragraph","text":"Когда вы обновляетесь до React 18, в консоли, когда вы используете ее в .render()качестве точки входа, появится журнал ошибок , в котором вам будет предложено переключиться на новый Root API.","spans":[]},{"type":"paragraph","text":"Вы можете попробовать функции React 18 только после того, как воспользуетесь createRoot()методом.","spans":[{"start":39,"end":45,"type":"strong"}]},{"type":"paragraph","text":"Для получения дополнительной информации вы можете посетить страницу обсуждения createRoot здесь .","spans":[{"start":59,"end":95,"type":"hyperlink","data":{"link_type":"Web","url":"https://github.com/reactwg/react-18/discussions/5"}}]},{"type":"heading1","text":"Улучшения автоматического пакетирования для рендеринга","spans":[]},{"type":"paragraph","text":"Как вы, возможно, уже знаете, React - это библиотека, которая повторно отображает пользовательский интерфейс в результате изменений состояния.","spans":[]},{"type":"paragraph","text":"Например, когда вы меняете значение произвольного состояния с trueна false, React должен «реагировать» путем повторного рендеринга пользовательского интерфейса, настраивая то, что вы видите на экране, в соответствии с написанным вами кодом.","spans":[]},{"type":"paragraph","text":"Следующий <App>компонент будет отображать заголовок черного или красного цвета в соответствии со colorзначением состояния:","spans":[]},{"type":"preformatted","text":"функция App () { \n  const [цвет, setColor] = useState (false);  функция handleClick () { \n    setColor ((цвет) =>! цвет); // реагируем на повторные рендеры \n  }  return ( \n    <div> \n      <button onClick = {handleClick}> Изменить цвет </button> \n      <h1 style = {{color: color? \"red\": \"black\"}}> Привет </h1> \n    </div> \n  ); \n}","spans":[]},{"type":"paragraph","text":"Каждый раз, когда setColor()метод выполняется, React немедленно повторно отображает пользовательский интерфейс.","spans":[]},{"type":"paragraph","text":"Пакетная обработка - это механизм, используемый React для группировки нескольких обновлений состояния в один повторный рендеринг. Благодаря пакетной обработке вы избежите ненужных рендеров и оптимизируете процесс рендеринга.","spans":[{"start":0,"end":18,"type":"strong"}]},{"type":"paragraph","text":"Возвращаясь к <App>примеру компонента, давайте добавим еще одно состояние, которое обновляется при handleClick()вызове метода:","spans":[]},{"type":"preformatted","text":"функция App () { \n  const [цвет, setColor] = useState (false); \n  const [clickCount, setClickCount] = useState (0); \n  \n  функция handleClick () { \n    setColor ((цвет) =>! цвет); \n    setClickCount ((клик) => клик + 1); \n  }  return ( \n    <div> \n      <button onClick = {handleClick}> Изменить цвет </button> \n      <h1 style = {{color: color? \"red\": \"black\"}}> \n        Здравствуйте, у вас количество кликов {clickCount} \n      </ h1>\n     </div> \n  ); \n}","spans":[]},{"type":"paragraph","text":"Без механизма пакетной обработки приведенный выше код будет повторно отображать пользовательский интерфейс дважды при каждом handleClick()вызове метода. Сначала обновить цвет, затем еще раз, чтобы обновить счетчик кликов.","spans":[]},{"type":"paragraph","text":"Однако механизм пакетной обработки, реализованный в React 17, не был согласован. Пакетирование не произойдет, если вы вызовете методы обновления состояния из обратного вызова.","spans":[]},{"type":"paragraph","text":"Например, предположим, что вы сначала извлекаете данные из API перед вызовом setColor()и setClickCount(). Механизм пакетной обработки не сработает, и React дважды повторно отрендерит пользовательский интерфейс:","spans":[]},{"type":"preformatted","text":"function handleClick () { \n  fetchUserData (). then (() => { \n    setCount (c => c + 1); // вызывает повторную визуализацию! \n    setFlag (f =>! f); // вызывает повторную визуализацию ! \n  }); \n}function fetchUserDate () { \n  // код для краткости опущен ... \n}","spans":[]},{"type":"paragraph","text":"То же самое происходит, когда вы помещаете методы обновления состояния в setTimeout()обратный вызов:","spans":[]},{"type":"preformatted","text":"функция handleClick () { \n  setTimeout (() => { \n    setColor ((цвет) =>! цвет); \n    setClickCount ((щелчок) => щелчок + 1); \n  }, 1000); \n}","spans":[]},{"type":"paragraph","text":"React 18 решил проблему выше, улучшив механизм дозирования.","spans":[]},{"type":"paragraph","text":"Теперь пакетная обработка запускается, когда более одного метода обновления состояния вызывается из внутренних обещаний, setTimeout, собственных обработчиков событий или любого другого события, которое ранее не было обработано React.","spans":[]},{"type":"paragraph","text":"Страницу обсуждения этой функции можно найти здесь .","spans":[{"start":45,"end":50,"type":"hyperlink","data":{"link_type":"Web","url":"https://github.com/reactwg/react-18/discussions/21"}}]},{"type":"heading1","text":"Поддержка SSR для <Suspense>","spans":[]},{"type":"paragraph","text":"<Suspense>Компонент является особенностью Реагировать библиотеки , которая позволяет ждать некоторого кода к нагрузке путем добавления fallbackкомпонента , чтобы сделать до загрузки кода.","spans":[]},{"type":"paragraph","text":"Вот пример <Suspense>в действии:","spans":[]},{"type":"preformatted","text":"<Suspense fallback = {<LoadingSpinner />}>\n   <UserProfile /> \n<Suspense />","spans":[]},{"type":"paragraph","text":"Вы можете <Suspense>подробно прочитать об этом в документации по React.","spans":[]},{"type":"paragraph","text":"В React 18 эта <Suspense>функция поддерживается даже при рендеринге компонентов на сервере с использованием SSR. Это обновление позволяет обернуть компоненты, отображаемые сервером, внутри <Suspense>компонента.","spans":[]},{"type":"paragraph","text":"Любые компоненты на стороне сервера, заключенные внутри, <Suspense>будут транслироваться как HTML, используя fallbackсначала компонент, и как только компонент будет готов, React отправит новые биты HTML для замены fallbackкомпонента.","spans":[]},{"type":"paragraph","text":"Например, предположим, что у вас есть <Article>следующие <Comments>компоненты и a :","spans":[]},{"type":"preformatted","text":"<Layout> \n  < Article /> \n  <Suspense fallback = {<Spinner />}>\n     <Comments /> \n  </Suspense>\n </Layout>","spans":[]},{"type":"paragraph","text":"При рендеринге с сервера <Article>компонент будет иметь приоритет, а <Comments>компонент будет заменен резервным компонентом <Spinner>. Как только <Comments>компонент отобразится на сервере, React отправит его в браузер, заменив <Spinner>компонент.","spans":[]},{"type":"paragraph","text":"Для более подробного объяснения SSR и Suspense вы можете посетить следующую страницу обсуждения GitHub .","spans":[{"start":85,"end":102,"type":"hyperlink","data":{"link_type":"Web","url":"https://github.com/reactwg/react-18/discussions/37"}}]},{"type":"heading1","text":"API startTransition для несрочных обновлений состояния","spans":[]},{"type":"paragraph","text":"startTransitionAPI является новой функцией в React 18 предназначен , чтобы помочь ваше пребывание приложений реагирующий при обновлении состояния , которое требует тяжелой мощности вычислений для визуализации пользовательского интерфейса.","spans":[]},{"type":"paragraph","text":"Одним из примеров такого обновления является создание поля ввода, которое фильтрует список данных. Обновление состояния требует, чтобы ваше приложение React вычисляло и отображало только те данные, которые соответствуют фильтру.","spans":[]},{"type":"paragraph","text":"У вас может быть два метода обновления состояния: один для обработки изменения входного значения, а другой для обработки запроса фильтра.","spans":[]},{"type":"preformatted","text":"// Устанавливаем состояние входного значения \nsetInputValue (input); \n\n// Устанавливаем ввод поискового запроса. Отражено позже в пользовательском интерфейсе \nsetSearchQuery (input);","spans":[]},{"type":"paragraph","text":"Когда количество фильтруемых элементов увеличивается, вычисления для фильтрации элементов также увеличиваются. Это может привести к тому, что ваше приложение будет работать медленно или даже зависнуть во время выполнения вычислений.","spans":[{"start":173,"end":200,"type":"em"}]},{"type":"paragraph","text":"Чтобы смягчить эту проблему, React позволяет отмечать определенные обновления как переходы .","spans":[{"start":82,"end":91,"type":"strong"},{"start":91,"end":92,"type":"em"}]},{"type":"paragraph","text":"Обновления перехода обрабатываются как несрочные обновления, что позволяет React в первую очередь расставлять приоритеты по срочным обновлениям.","spans":[]},{"type":"paragraph","text":"Вернемся к примеру, обновление поискового запроса может быть отложено, если поместить его в startTransitionAPI следующим образом:","spans":[]},{"type":"preformatted","text":"импортировать {startTransition} из \"реагировать\";// Срочно: показать, что было набрано \nsetInputValue (input);// Помечаем любые обновления состояния внутри как переходы \nstartTransition (() => { \n  setSearchQuery (input); \n});","spans":[]},{"type":"paragraph","text":"Обернутые обновления startTransitionбудут прерваны при запуске более важных обновлений.","spans":[]},{"type":"paragraph","text":"В приведенном выше примере обновление перехода для поискового запроса будет остановлено, когда пользователь наберет несколько символов в строке. Это оптимизирует производительность повторного рендеринга React и устраняет ненужные вычисления для устаревших обновлений.","spans":[]},{"type":"paragraph","text":"Вы можете найти больше информации о startTransition API здесь .","spans":[{"start":36,"end":61,"type":"hyperlink","data":{"link_type":"Web","url":"https://github.com/reactwg/react-18/discussions/41"}}]},{"type":"heading1","text":"Заключение","spans":[]},{"type":"paragraph","text":"Хотя некоторые функции, упомянутые на вводной странице React 18, еще даже не были выпущены ( useDeferredValueи, <SuspenseList>например)","spans":[{"start":38,"end":45,"type":"hyperlink","data":{"link_type":"Web","url":"https://github.com/reactwg/react-18/discussions/4"}},{"start":55,"end":64,"type":"hyperlink","data":{"link_type":"Web","url":"https://github.com/reactwg/react-18/discussions/4"}}]},{"type":"paragraph","text":"React 18 Alpha уже привносит в React несколько интересных функций, улучшающих параллелизм библиотеки. Вы можете попробовать это, установив @alphaсборку reactи react-domбиблиотеку.","spans":[]},{"type":"paragraph","text":"Также пока нет обновлений для компонентов сервера React , но новые параллельные функции, такие как поддержка SSR для приостановки и потоковая передача HTML с сервера, могут помочь в реализации компонентов сервера позже.","spans":[{"start":26,"end":55,"type":"hyperlink","data":{"link_type":"Web","url":"https://blog.bitsrc.io/react-server-components-1ca621ac2519"}}]},{"type":"paragraph","text":"Релиз график React 18 выглядит следующим образом :","spans":[{"start":0,"end":21,"type":"hyperlink","data":{"link_type":"Web","url":"https://reactjs.org/blog/2021/06/08/the-plan-for-react-18.html"}}]},{"type":"list-item","text":"Альфа-версия для сбора отзывов и поддержки рабочей группы React (доступна сегодня)","spans":[]},{"type":"list-item","text":"Публичная бета-версия для всех остальных (по крайней мере, через несколько месяцев после выпуска альфа-версии)","spans":[]},{"type":"list-item","text":"Сборка Release Candidate (RC) через несколько недель после публичной бета-версии","spans":[]},{"type":"list-item","text":"Стабильный выпуск выйдет через несколько недель после RC.","spans":[]},{"type":"paragraph","text":"Спасибо, что прочитали эту статью. Не стесняйтесь попробовать React 18 самостоятельно, но имейте в виду, что могут быть критические изменения в зависимости от того, насколько сложным является ваше приложение React.","spans":[]}],"text":"Примечательные функции, которые вы уже можете попробовать в React 18, следующие: Новый ReactDOM.createRoot()API, заменяющийReactDOM.render() Улучшения пакетной обработки для меньшего количества рендеров Поддержка SSR для <Suspense>компонента startTransition API для несрочных обновлений состояния Чтобы опробовать React 18 Alpha в своем проекте, вы можете установить @alphaверсию из NPM или Yarn: npm install react @ alpha react-dom @ alpha \n# или \nпряжа add response @ alpha react-dom @ alpha Если вы загрузите свое приложение React с помощью приложения Create React, вы можете столкнуться с ошибкой, could not resolve dependencyвызванной react-scriptsследующим: Не удалось разрешить зависимость: \npeer response @ \"> = 16\" из response-scripts@4.0.3 Вы можете использовать --forceфлаг, чтобы вы могли обновлять как библиотеки, так reactи react-dom: npm установить react @ alpha react-dom @ alpha --force Это руководство поможет вам изучить новые функции, уже представленные в React 18 Alpha, которые я смог попробовать сам. ReactDOM.createRoot () API объяснил ReactDOM.createRoot()Метод заменяет ReactDOM.render()метод , который обычно используется в качестве точки входа вашего React приложения. Этот метод создан для предотвращения сбоя вашего приложения при обновлении React 18. Новый метод также позволяет создавать производственную сборку с использованием React 18 Alpha и сравнивать производительность с React 17. Вот пример того, как использовать createRoot()метод: импортировать React из React; \nимпортировать ReactDOM из react-dom; \nимпортировать приложение из './App';const container = document.getElementById ('корень');// Создаем корень. \nconst root = ReactDOM.createRoot (контейнер);// Отрисовываем верхний компонент в корень. \nroot.render (<Приложение />); Когда вы обновляетесь до React 18, в консоли, когда вы используете ее в .render()качестве точки входа, появится журнал ошибок , в котором вам будет предложено переключиться на новый Root API. Вы можете попробовать функции React 18 только после того, как воспользуетесь createRoot()методом. Для получения дополнительной информации вы можете посетить страницу обсуждения createRoot здесь . Улучшения автоматического пакетирования для рендеринга Как вы, возможно, уже знаете, React - это библиотека, которая повторно отображает пользовательский интерфейс в результате изменений состояния. Например, когда вы меняете значение произвольного состояния с trueна false, React должен «реагировать» путем повторного рендеринга пользовательского интерфейса, настраивая то, что вы видите на экране, в соответствии с написанным вами кодом. Следующий <App>компонент будет отображать заголовок черного или красного цвета в соответствии со colorзначением состояния: функция App () { \n  const [цвет, setColor] = useState (false);  функция handleClick () { \n    setColor ((цвет) =>! цвет); // реагируем на повторные рендеры \n  }  return ( \n    <div> \n      <button onClick = {handleClick}> Изменить цвет </button> \n      <h1 style = {{color: color? \"red\": \"black\"}}> Привет </h1> \n    </div> \n  ); \n} Каждый раз, когда setColor()метод выполняется, React немедленно повторно отображает пользовательский интерфейс. Пакетная обработка - это механизм, используемый React для группировки нескольких обновлений состояния в один повторный рендеринг. Благодаря пакетной обработке вы избежите ненужных рендеров и оптимизируете процесс рендеринга. Возвращаясь к <App>примеру компонента, давайте добавим еще одно состояние, которое обновляется при handleClick()вызове метода: функция App () { \n  const [цвет, setColor] = useState (false); \n  const [clickCount, setClickCount] = useState (0); \n  \n  функция handleClick () { \n    setColor ((цвет) =>! цвет); \n    setClickCount ((клик) => клик + 1); \n  }  return ( \n    <div> \n      <button onClick = {handleClick}> Изменить цвет </button> \n      <h1 style = {{color: color? \"red\": \"black\"}}> \n        Здравствуйте, у вас количество кликов {clickCount} \n      </ h1>\n     </div> \n  ); \n} Без механизма пакетной обработки приведенный выше код будет повторно отображать пользовательский интерфейс дважды при каждом handleClick()вызове метода. Сначала обновить цвет, затем еще раз, чтобы обновить счетчик кликов. Однако механизм пакетной обработки, реализованный в React 17, не был согласован. Пакетирование не произойдет, если вы вызовете методы обновления состояния из обратного вызова. Например, предположим, что вы сначала извлекаете данные из API перед вызовом setColor()и setClickCount(). Механизм пакетной обработки не сработает, и React дважды повторно отрендерит пользовательский интерфейс: function handleClick () { \n  fetchUserData (). then (() => { \n    setCount (c => c + 1); // вызывает повторную визуализацию! \n    setFlag (f =>! f); // вызывает повторную визуализацию ! \n  }); \n}function fetchUserDate () { \n  // код для краткости опущен ... \n} То же самое происходит, когда вы помещаете методы обновления состояния в setTimeout()обратный вызов: функция handleClick () { \n  setTimeout (() => { \n    setColor ((цвет) =>! цвет); \n    setClickCount ((щелчок) => щелчок + 1); \n  }, 1000); \n} React 18 решил проблему выше, улучшив механизм дозирования. Теперь пакетная обработка запускается, когда более одного метода обновления состояния вызывается из внутренних обещаний, setTimeout, собственных обработчиков событий или любого другого события, которое ранее не было обработано React. Страницу обсуждения этой функции можно найти здесь . Поддержка SSR для <Suspense> <Suspense>Компонент является особенностью Реагировать библиотеки , которая позволяет ждать некоторого кода к нагрузке путем добавления fallbackкомпонента , чтобы сделать до загрузки кода. Вот пример <Suspense>в действии: <Suspense fallback = {<LoadingSpinner />}>\n   <UserProfile /> \n<Suspense /> Вы можете <Suspense>подробно прочитать об этом в документации по React. В React 18 эта <Suspense>функция поддерживается даже при рендеринге компонентов на сервере с использованием SSR. Это обновление позволяет обернуть компоненты, отображаемые сервером, внутри <Suspense>компонента. Любые компоненты на стороне сервера, заключенные внутри, <Suspense>будут транслироваться как HTML, используя fallbackсначала компонент, и как только компонент будет готов, React отправит новые биты HTML для замены fallbackкомпонента. Например, предположим, что у вас есть <Article>следующие <Comments>компоненты и a : <Layout> \n  < Article /> \n  <Suspense fallback = {<Spinner />}>\n     <Comments /> \n  </Suspense>\n </Layout> При рендеринге с сервера <Article>компонент будет иметь приоритет, а <Comments>компонент будет заменен резервным компонентом <Spinner>. Как только <Comments>компонент отобразится на сервере, React отправит его в браузер, заменив <Spinner>компонент. Для более подробного объяснения SSR и Suspense вы можете посетить следующую страницу обсуждения GitHub . API startTransition для несрочных обновлений состояния startTransitionAPI является новой функцией в React 18 предназначен , чтобы помочь ваше пребывание приложений реагирующий при обновлении состояния , которое требует тяжелой мощности вычислений для визуализации пользовательского интерфейса. Одним из примеров такого обновления является создание поля ввода, которое фильтрует список данных. Обновление состояния требует, чтобы ваше приложение React вычисляло и отображало только те данные, которые соответствуют фильтру. У вас может быть два метода обновления состояния: один для обработки изменения входного значения, а другой для обработки запроса фильтра. // Устанавливаем состояние входного значения \nsetInputValue (input); \n\n// Устанавливаем ввод поискового запроса. Отражено позже в пользовательском интерфейсе \nsetSearchQuery (input); Когда количество фильтруемых элементов увеличивается, вычисления для фильтрации элементов также увеличиваются. Это может привести к тому, что ваше приложение будет работать медленно или даже зависнуть во время выполнения вычислений. Чтобы смягчить эту проблему, React позволяет отмечать определенные обновления как переходы . Обновления перехода обрабатываются как несрочные обновления, что позволяет React в первую очередь расставлять приоритеты по срочным обновлениям. Вернемся к примеру, обновление поискового запроса может быть отложено, если поместить его в startTransitionAPI следующим образом: импортировать {startTransition} из \"реагировать\";// Срочно: показать, что было набрано \nsetInputValue (input);// Помечаем любые обновления состояния внутри как переходы \nstartTransition (() => { \n  setSearchQuery (input); \n}); Обернутые обновления startTransitionбудут прерваны при запуске более важных обновлений. В приведенном выше примере обновление перехода для поискового запроса будет остановлено, когда пользователь наберет несколько символов в строке. Это оптимизирует производительность повторного рендеринга React и устраняет ненужные вычисления для устаревших обновлений. Вы можете найти больше информации о startTransition API здесь . Заключение Хотя некоторые функции, упомянутые на вводной странице React 18, еще даже не были выпущены ( useDeferredValueи, <SuspenseList>например) React 18 Alpha уже привносит в React несколько интересных функций, улучшающих параллелизм библиотеки. Вы можете попробовать это, установив @alphaсборку reactи react-domбиблиотеку. Также пока нет обновлений для компонентов сервера React , но новые параллельные функции, такие как поддержка SSR для приостановки и потоковая передача HTML с сервера, могут помочь в реализации компонентов сервера позже. Релиз график React 18 выглядит следующим образом : Альфа-версия для сбора отзывов и поддержки рабочей группы React (доступна сегодня) Публичная бета-версия для всех остальных (по крайней мере, через несколько месяцев после выпуска альфа-версии) Сборка Release Candidate (RC) через несколько недель после публичной бета-версии Стабильный выпуск выйдет через несколько недель после RC. Спасибо, что прочитали эту статью. Не стесняйтесь попробовать React 18 самостоятельно, но имейте в виду, что могут быть критические изменения в зависимости от того, насколько сложным является ваше приложение React."},"date":"2021-06-15","item_image":{"url":"https://images.prismic.io/multilang-prismic-gatsby-example/ff96898c-e2e8-4964-8d75-c53fdd74ee04_1_ZVFiavGnNXNIhQwuhMHUgQ.png?auto=compress%2Cformat"},"short_description":{"html":"<p>Команда React недавно выпустила новую <a  href=\"https://github.com/reactwg/react-18/discussions/4\">альфа-версию React 18</a> . Основное дополнение к этой новой версии - это параллельные функции, улучшающие производительность вашего приложения React.</p>","raw":[{"type":"paragraph","text":"Команда React недавно выпустила новую альфа-версию React 18 . Основное дополнение к этой новой версии - это параллельные функции, улучшающие производительность вашего приложения React.","spans":[{"start":38,"end":59,"type":"hyperlink","data":{"link_type":"Web","url":"https://github.com/reactwg/react-18/discussions/4"}}]}],"text":"Команда React недавно выпустила новую альфа-версию React 18 . Основное дополнение к этой новой версии - это параллельные функции, улучшающие производительность вашего приложения React."}}],"slice_label":null,"slice_type":"blog","primary":{"blog_title":{"html":"<h1>Мой блог</h1>","raw":[{"type":"heading1","text":"Мой блог","spans":[]}],"text":"Мой блог"}}}]}},"prismicTopMenu":{"type":"top_menu","lang":"ru","data":{"menu_links":[{"label":{"raw":[{"type":"paragraph","text":"Главная","spans":[]}],"html":"<p>Главная</p>","text":"Главная"},"link":{"id":"YMDH5BEAACUA05sq","url":"/ru"}},{"label":{"raw":[{"type":"paragraph","text":"Обо мне","spans":[]}],"html":"<p>Обо мне</p>","text":"Обо мне"},"link":{"id":"YMDJIREAACIA06Eo","url":"/page/ru/about-me"}},{"label":{"raw":[{"type":"paragraph","text":"Мои работы","spans":[]}],"html":"<p>Мои работы</p>","text":"Мои работы"},"link":{"id":"YMDKFBEAACQA06WB","url":"/page/ru/my-projects"}},{"label":{"raw":[{"type":"paragraph","text":"Блог","spans":[]}],"html":"<p>Блог</p>","text":"Блог"},"link":{"id":"YMImKhEAACUA2XEN","url":"/page/ru/blog-page"}},{"label":{"raw":[{"type":"paragraph","text":"MetaMask","spans":[]}],"html":"<p>MetaMask</p>","text":"MetaMask"},"link":{"id":"YMM2rBEAACIA3jQf","url":"/page/ru/metamask"}}]}}},"pageContext":{"id":"bfc9b41f-c3fc-5969-aeac-dd139fb1292b","uid":"blog-page","lang":"ru","type":"page","url":"/page/ru/blog-page"}}